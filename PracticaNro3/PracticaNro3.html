<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
</head>
<body>
    <canvas id="webglcanvas" width="600" height="700"></canvas>

    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec2 aVertices;
        layout(location = 1) in vec4 aColores;  
        out vec4 vColores;  
        void main() {
            vColores = aColores;
            gl_Position = uMatrizProyeccion * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        in vec4 vColores;
        out vec4 color;
        void main() {
            color = vColores;
        }
    </script>

    <script>
        
        /* Convierte de grados a radianes */
        function toRadians(grados) {
            return grados * Math.PI / 180;
        }

         /* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
            let r = new Array(16);
            r[0] = 1; r[4] = 0; r[8] = 0; r[12] = tx;
            r[1] = 0; r[5] = 1; r[9] = 0; r[13] = ty;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
            multiplica(matriz, matriz, r);
        }

        /* Escalación - glScalef */
        function escalacion(matriz, sx, sy, sz) {
            let r = new Array(16);
            r[0] = sx; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = sy; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = sz; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
            multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] = 0; r[8] = 0; r[12] = -(der + izq)/(der - izq);
            r[1] = 0; r[5] = 2/(arr - abj); r[9] = 0; r[13] = -(arr + abj)/(arr - abj);
            r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

         /* Multiplicación de matrices de 4 x 4 */
        function multiplica(c, a, b) {
            let r = new Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    let s = 0;
                    for (let k = 0; k < 4; k++)
                        s += a[i + k * 4] * b[k + j * 4];
                    r[i + j * 4] = s;
                }
            }
            for (let i = 0; i < 16; i++)
                c[i] = r[i];
        }

        //clases para el juego
        class Paleta {
            constructor(x, y, ancho, alto) {
                this.x = x;
                this.y = y;
                this.ancho = ancho;
                this.alto = alto;
            }

            mover(direccion) {
                this.x += direccion * 0.3;
                if (this.x < -5) this.x = -5;
                if (this.x + this.ancho > 5) this.x = 5 - this.ancho;
            }
        }

        class Pelota {
            constructor(x, y, radio) {
                this.x = x;
                this.y = y;
                this.radio = radio;
                this.velocidadX = 0.08;
                this.velocidadY = 0.08;
            }

            mover() {
                this.x += this.velocidadX;
                this.y += this.velocidadY;

                if (this.x - this.radio < -5 || this.x + this.radio > 5) {
                    this.velocidadX *= -1;
                }
                if (this.y + this.radio > 5) {
                    this.velocidadY *= -1;
                }

                if (this.y < -5) {
                    this.reiniciar();
                }
            }

            rebotarPaleta() {
                this.velocidadY = Math.abs(this.velocidadY);
            }

            rebotarLadrillo() {
                this.velocidadY *= -1;
            }

            reiniciar() {
                this.x = 0;
                this.y = -3.5;
                this.velocidadX = 0.08;
                this.velocidadY = 0.08;
            }
        }

        class Ladrillo {
            constructor(x, y, ancho, alto, color) {
                this.x = x;
                this.y = y;
                this.ancho = ancho;
                this.alto = alto;
                this.color = color;
                this.activo = true;
            }

            destruir() {
                this.activo = false;
            }
        }
        
        let canvas, gl;
        let MatrizProyeccion = new Array(16);
        let MatrizModelo = new Array(16);
        let uMatrizProyeccion, uMatrizModelo;
        let rectanguloVAO;
        let circulosVAO = {};
        let paleta;
        let pelota;
        let ladrillos = [];
        let teclas = {};

        // Crear rectángulo
        function crearRectangulo(r, g, b) {
            let vertices = [
                -0.5, -0.5,
                 0.5, -0.5,
                 0.5,  0.5,
                -0.5,  0.5
            ];

            let colores = [
                r, g, b, 1,
                r, g, b, 1,
                r, g, b, 1,
                r, g, b, 1
            ];

            let vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            // Buffer de vértices
            let bufferVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            // Buffer de colores
            let bufferColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            return vao;
        }

        //crear circunferencia
        function circunferencia(radio, r, g, b) {
            let vertices = [];
            let colores = [];
            
            vertices.push(0, 0);
            colores.push(r, g, b, 1);
            
            for (let i = 0; i <= 360; i++) {
                vertices.push(radio * Math.cos(i * Math.PI / 180));
                vertices.push(radio * Math.sin(i * Math.PI / 180));
                colores.push(r, g, b, 1);
            }
            
            let circulo = gl.createVertexArray();
            gl.bindVertexArray(circulo);

            // Buffer de vértices
            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            // Buffer de colores
            let codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            
            return circulo;
        }

        function obtenerCirculoVAO(r, g, b) {
            let clave = `${r}_${g}_${b}`;
            
            if (!circulosVAO[clave]) {
                circulosVAO[clave] = circunferencia(1, 1, 1, 1);
            }
            
            return circulosVAO[clave];
        }

        function hayColision(circulo, rectangulo) {
            let cercanoX = Math.max(rectangulo.x, Math.min(circulo.x, rectangulo.x + rectangulo.ancho));
            let cercanoY = Math.max(rectangulo.y, Math.min(circulo.y, rectangulo.y + rectangulo.alto));
            
            let distanciaX = circulo.x - cercanoX;
            let distanciaY = circulo.y - cercanoY;
            let distancia = Math.sqrt(distanciaX * distanciaX + distanciaY * distanciaY);
            
            return distancia < circulo.radio;
        }


        function dibujarRectangulo(x, y, ancho, alto, r, g, b) {
            let vao = crearRectangulo(r, g, b);
            
            identidad(MatrizModelo);
            traslacion(MatrizModelo, x + ancho/2, y + alto/2, 0);
            escalacion(MatrizModelo, ancho, alto, 1);
        
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
            
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            gl.bindVertexArray(null);
        }

        function dibujarCirculo(x, y, radio, r, g, b) {
            let vao = obtenerCirculoVAO(r, g, b);
            
            identidad(MatrizModelo);
            traslacion(MatrizModelo, x, y, 0);
            escalacion(MatrizModelo, radio, radio, 1);
            
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
            
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 362);
            gl.bindVertexArray(null);
        }

       //iniciar juego

        function inicializar() {
            paleta = new Paleta(-1, -4.5, 3, 0.3);
            pelota = new Pelota(0, -3.5, 0.2);
            
            ladrillos = [];
            let anchoLadrillo = 1.15;
            let altoLadrillo = 0.4;
            let separacion = 0.1;

            let colores = [
                [1, 0, 0],
                [1, 0.5, 0],
                [1, 1, 0],
                [0, 1, 0],
                [0, 0, 1]
            ];

            for (let fila = 0; fila < 5; fila++) {
                for (let col = 0; col < 8; col++) {
                    let espacioTotal = 8 * anchoLadrillo + 7 * separacion;
                    let inicioX = -espacioTotal / 2;
                    let x = inicioX + col * (anchoLadrillo + separacion);
                    let y = 2 + fila * (altoLadrillo + separacion);
                    ladrillos.push(new Ladrillo(x, y, anchoLadrillo, altoLadrillo, colores[fila]));
                }
            }
        }


        function actualizar() {
            if (teclas['ArrowLeft']) paleta.mover(-1);
            if (teclas['ArrowRight']) paleta.mover(1);

            pelota.mover();

            if (hayColision(pelota, paleta)) {
                pelota.rebotarPaleta();
            }

            for (let ladrillo of ladrillos) {
                if (ladrillo.activo && hayColision(pelota, ladrillo)) {
                    ladrillo.destruir();
                    pelota.rebotarLadrillo();
                    // pelota.velocidadX *= 2.02;
                    // pelota.velocidadY *= 2.02;
                    break;
                }
            }

            if (ladrillos.every(l => !l.activo)) {
                alert('¡Ganaste!');
                inicializar();
            }
        }

        function dibujar() {
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Dibujar paleta (blanca)
            dibujarRectangulo(paleta.x, paleta.y, paleta.ancho, paleta.alto, 1, 1, 1);

            // Dibujar pelota (blanca)
            dibujarCirculo(pelota.x, pelota.y, pelota.radio, 1, 1, 1);

            // Dibujar ladrillos
            for (let ladrillo of ladrillos) {
                if (ladrillo.activo) {
                    dibujarRectangulo(
                        ladrillo.x, ladrillo.y, 
                        ladrillo.ancho, ladrillo.alto,
                        ladrillo.color[0], ladrillo.color[1], ladrillo.color[2]
                    );
                }
            }
        }

        function loop() {
            actualizar();
            dibujar();
            requestAnimationFrame(loop);
        }

        window.addEventListener('keydown', (e) => {
            teclas[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            teclas[e.key] = false;
        });


        function main() {
            canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");
        
            gl.viewport(0, 0, canvas.width, canvas.height);

            let shaderVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderVertice, document.getElementById("vs").text.trim());
            gl.compileShader(shaderVertice);

            let shaderFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderFragmento, document.getElementById("fs").text.trim());
            gl.compileShader(shaderFragmento);

            let programa = gl.createProgram();
            gl.attachShader(programa, shaderVertice);
            gl.attachShader(programa, shaderFragmento);
            gl.linkProgram(programa);
            gl.useProgram(programa);

            uMatrizProyeccion = gl.getUniformLocation(programa, "uMatrizProyeccion");
            uMatrizModelo = gl.getUniformLocation(programa, "uMatrizModelo");

            ortho(MatrizProyeccion, -5, 5, -5, 5, -1, 1);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            gl.clearColor(0.1, 0.1, 0.15, 1.0);

            inicializar();
            loop();
        }

        window.onload = main;
    </script>
</body>
</html>