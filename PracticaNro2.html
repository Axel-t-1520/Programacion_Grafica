<html lang="es">

<head>
</head>

<body>
    <canvas id="webglcanvas" style="border: none" width="500" height="500">
    </canvas>
    <script id="vs" type="vertex">
            #version 300 es
            uniform mat4 uMatrizProyeccion;
            uniform mat4 uMatrizVista;
            uniform mat4 uMatrizModelo;
            layout(location = 0) in vec2 aVertices; 
            layout (location = 1) in vec4 aColores; // (r,g,b,a)
            void main() {
                gl_Position = uMatrizProyeccion* uMatrizVista * uMatrizModelo * vec4(aVertices,0.0,1.0);  
            }
        </script>
    <script id="fs" type="fragment">
            #version 300 es
            precision mediump float;
            uniform vec4 uColor;  
            out vec4 color;
            void main(){
                color = uColor;
            }
        </script>
    <script>
        let programaID;
        let gl, canvas;
        let circulo;
        let xVAO;


        let uMatrizProyeccion;
        let uMatrizVista;
        let uMatrizModelo;

        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);

        let Matriz = new Array(9).fill(0);
        let turno = 1;
        let juegoTerminado = false; 

        
        const combinacionesGanadoras = [
            [0, 1, 2],
            [3, 4, 5], 
            [6, 7, 8],

            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],

            [0, 4, 8],
            [2, 4, 6]
        ];

        /* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }
        /* ProyecciÃ³n Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2 / (der - izq); r[4] = 0; r[8] = 0; r[12] = -(der + izq) / (der - izq);
            r[1] = 0; r[5] = 2 / (arr - abj); r[9] = 0; r[13] = -(arr + abj) / (arr - abj);
            r[2] = 0; r[6] = 0; r[10] = -2 / (lejos - cerca); r[14] = -(lejos + cerca) / (lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

         function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
                r[i + j * 4] = s;
              }
            }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }

        
        function circunferencia(radio,r,g,b){
           /* Las coordenadas cartesianas (x, y) */
            let vertices = [];

            /* Los colores x c/vértice (r,g,b,a) */
            let colores = [];

            /* Lee los vértices (x,y) y colores (r,g,b,a) */
            for (let i = 0; i < 360; i++) {
               vertices.push(radio * Math.cos(i * Math.PI / 180)); // x
               vertices.push(radio * Math.sin(i * Math.PI / 180)); // y

               colores.push(r);
               colores.push(g);
               colores.push(b);
               colores.push(1);
            }

            circulo = gl.createVertexArray();
            gl.bindVertexArray(circulo);

            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            let codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);


        }

        function crearX() {
            let vertices = [

                -0.8, 0.8,
                0.8, -0.8,

                0.8, 0.8,
                -0.8, -0.8
            ];

            xVAO = gl.createVertexArray();
            gl.bindVertexArray(xVAO);

            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }

        function verificarGanador() {
            for (let i = 0; i < combinacionesGanadoras.length; i++) {
                const [a, b, c] = combinacionesGanadoras[i];

                if (Matriz[a] !== 0 && 
                    Matriz[a] === Matriz[b] && 
                    Matriz[b] === Matriz[c]) {
                    
                    return Matriz[a];
                }
            }
            
            if (Matriz.every(cuadro => cuadro !== 0)) {
                return 'empate';
            }
            
            return null; 
        }

        function mostrarResultado(resultado) {
            if (resultado === 1) {
                alert("¡Ganaron jugador 1");
            } else if (resultado === 2) {
                alert("¡Ganó la jugador 2");
            } else if (resultado !== 1 && resultado !== 2) {
                alert("¡EMPATE!");
            }
        }

        function obtenerCentroCuadro(indice) {
            const centros = [
                [-3.25, 2.75],  
                [0, 2.75],     
                [3.25, 2.75],  
                [-3.25, 0],     
                [0, 0],        
                [3.25, 0],      
                [-3.25, -2.75], 
                [0, -2.75],     
                [3.25, -2.75]
            ];
            return centros[indice];
        }

        function dibuja() {

            gl.clear(gl.COLOR_BUFFER_BIT);
            //RENDERIZA
            gl.bindVertexArray(rectanguloVAO);
            gl.uniform4f(uColor, 1, 0, 0, 1);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            gl.bindVertexArray(null);
        }

        function puntoEstaDentroDelRectangulo(x, y, x1, y1, ancho, alto) {
            var x2 = x1 + ancho;
            var y2 = y1 + alto;
            return (x1 < x && x < x2 && y1 < y && y < y2);
        }

        function main() {

            function mouseDown(e) {
                var posx = e.x - canvas.offsetLeft;
                var posy = e.y - canvas.offsetTop;

                var x = (posx * 10) / 500 - 5;
                var y = (10 - (posy * 10) / 500) - 5;

                const cuadros = [
                    [-4.5, 1.5, 2.5, 2.5], // 0
                    [-1.25, 1.5, 2.5, 2.5], // 1
                    [2.0, 1.5, 2.5, 2.5], // 2
                    [-4.5, -1.25, 2.5, 2.5], // 3
                    [-1.25, -1.25, 2.5, 2.5], // 4
                    [2.0, -1.25, 2.5, 2.5], // 5
                    [-4.5, -4.0, 2.5, 2.5], // 6
                    [-1.25, -4.0, 2.5, 2.5], // 7
                    [2.0, -4.0, 2.5, 2.5], // 8
                ];

                for (let i = 0; i < cuadros.length; i++) {
                    const [x1, y1, ancho, alto] = cuadros[i];
                    if (puntoEstaDentroDelRectangulo(x, y, x1, y1, ancho, alto)) {
                        console.log((i-1).toString());
                        if (Matriz[i] === 0 && !juegoTerminado) {
                            Matriz[i] = turnoActual;
    
                            const resultado = verificarGanador();
                            if (resultado !== null) {
                                juegoTerminado = true;
                                redibujarTodo();
                                
                                mostrarResultado(resultado);

                            } else {
                                turnoActual = turnoActual === 1 ? 2 : 1; 
                                redibujarTodo();
                            }
                        }
                        break;
                    }
                }

            }
            let uMatrizProyeccion;
            let uMatrizVista;
            let uMatrizModelo;

            let MatrizProyeccion = new Array(16);
            let MatrizVista = new Array(16);
            let MatrizModelo = new Array(16);

            canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");

            gl.viewport(0, 0, canvas.width, canvas.height);

            canvas.addEventListener("mousedown", mouseDown, false);
            // Compilar shaders
            var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
            gl.compileShader(shaderDeVertice);

            var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
            gl.compileShader(shaderDeFragmento);

            programaID = gl.createProgram();
            gl.attachShader(programaID, shaderDeVertice);
            gl.attachShader(programaID, shaderDeFragmento);
            gl.linkProgram(programaID);
            gl.useProgram(programaID);

            // Geometría (ordenada para LINE_STRIP)
            var vertices = [

                -2.0, 4.0, -4.5, 4.0, -4.5, 1.5, -2.0, 1.5,   
                1.25, 4.0, -1.25, 4.0, -1.25, 1.5, 1.25, 1.5,  
                4.5, 4.0, 2.0, 4.0, 2.0, 1.5, 4.5, 1.5,  

                -2.0, 1.25, -4.5, 1.25, -4.5, -1.25, -2.0, -1.25,  
                1.25, 1.25, -1.25, 1.25, -1.25, -1.25, 1.25, -1.25,
                4.5, 1.25, 2.0, 1.25, 2.0, -1.25, 4.5, -1.25,  

                -2.0, -1.5, -4.5, -1.5, -4.5, -4.0, -2.0, -4.0,  
                1.25, -1.5, -1.25, -1.5, -1.25, -4.0, 1.25, -4.0,  
                4.5, -1.5, 2.0, -1.5, 2.0, -4.0, 4.5, -4.0  
            ];


            var triangulos = gl.createVertexArray();
            gl.bindVertexArray(triangulos);
            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            // let codigoDeIndices = gl.createBuffer();
            // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            // gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        
            crearX();

            
            gl.clearColor(167 / 255, 255 / 255, 180 / 255, 1);

            var uColor = gl.getUniformLocation(programaID, "uColor");
            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

            ortho(MatrizProyeccion, -5, 5, -5, 5, -1, 1);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

            identidad(MatrizModelo);
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

            function redibujarTodo() {
                gl.clear(gl.COLOR_BUFFER_BIT);
                identidad(MatrizModelo);
                gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

                gl.bindVertexArray(triangulos);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 4, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 8, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 12, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 16, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 20, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 24, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 28, 4);

                gl.uniform4f(uColor, 0, 0, 0, 1);
                gl.drawArrays(gl.TRIANGLE_FAN, 32, 4);

                gl.bindVertexArray(null);


                for (let i = 0; i < 9; i++) {
                    if (Matriz[i] !== 0) {
                        const [posX, posY] = obtenerCentroCuadro(i);
                        
                        identidad(MatrizModelo);
                        traslacion(MatrizModelo, posX, posY, 0);
                        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

                        if (Matriz[i] === 1) {
                            circunferencia(0.8, 0, 0, 1);
                            gl.uniform4f(uColor, 0, 0, 1, 1);
                            gl.bindVertexArray(circulo);
                            gl.drawArrays(gl.LINE_LOOP, 0, 360);
                            gl.bindVertexArray(null);
                        } else if (Matriz[i] === 2) {
                            gl.uniform4f(uColor, 1, 0, 0, 1);
                            gl.bindVertexArray(xVAO);
                            gl.lineWidth(3);
                            gl.drawArrays(gl.LINES, 0, 2);
                            gl.drawArrays(gl.LINES, 2, 2);
                            gl.bindVertexArray(null);
                        }
                    }
                }
            }
            window.redibujarTodo = redibujarTodo;

            redibujarTodo();

            gl.bindVertexArray(null);
        }
        window.onload = main; 
    </script>
</body>

</html>